import sys
sys.path.append("..")
from _paths import *
import subprocess
import csv
from itertools import combinations
import os
import numpy as np

#iids = ['rnd_200_1024']
block_size = 4
avail_compr = ipair.avail_compr

def i(s, idir=idir):
    return os.path.join(idir, s)


def exec_diff(f1, f2):
    res = subprocess.check_call(f"diff -q {f1} {f2}", shell=True)
    if int(res) == 0:
        return "OK"
    return "FAIL"


def exec_count(fname):
    command = f"wc -w {fname}"
    res = subprocess.check_output(command, shell=True).decode()
    return int(res.split()[0])


def get_range_endpoints(ilen):
    range_idx = ([(_, _ + 4) for _ in range(1, ilen - 4, 4)] +
                 [(_, _ + 1) for _ in range(1, ilen - 1, 1)])
    return range_idx


def exec_range_query(ip_inst, from_idx, to_idx, method, compr):
    ms_path = ip_inst.compr_ms_path(compr)
    bsize = {"djamal": -1, "trivial": 0, 'indexed': block_size}[method]
    command = (f"{range_query} -compression {compr} "
               f"-ms_path {ms_path} "
               f"-block_size {bsize} "
               f"-from_idx {from_idx} -to_idx {to_idx} ")
    if method == 'indexed':
        command += ' -ridx_path %s' % ip_inst.ridx(bsize)

    res = subprocess.check_output(command, shell=True).decode().strip()
    return int(res.split(": ")[1])


def exec_multiple_range_queries(ipair_instance, method, compr):
    mstat_path = i(ipair_instance.mstat)
    ilen = exec_count(mstat_path)

    if method == 'correct':
        np_data = np.loadtxt(mstat_path)
        assert np_data.shape[0] == ilen

        for start, end in get_range_endpoints(np_data.shape[0]):
            yield start, end, int(np_data[start:end].sum())
    else:
        for start, end in get_range_endpoints(ilen):
            res = exec_range_query(ipair_instance, start, end, method, compr)
            yield start, end, res

wildcard_constraints:
    compr="(" + ")|(".join(avail_compr) + ")",

rule all:
    input:
        expand("{inid}.{compr}.check", inid=iids, compr=avail_compr)
    shell:
        ("cat {input}")


rule check:
    input:
        d="{inid}.{compr}.djamal",
        f="{inid}.{compr}.trivial",
        i="{inid}.{compr}.indexed",
        c="{inid}.{compr}.correct"
    output:
        "{inid}.{compr}.check"
    run:
        with open(str(output), 'w') as out_fd:
            for d in [input.d, input.f, input.i]:
                print(d, exec_diff(d, input.c), file=out_fd)


rule noridix_rquery:
    wildcard_constraints:
        method="(djamal)|(trivial)|(correct)"
    input:
        ms=ipair("{inid}").compr_ms_path("{compr}")
    output:
        "{inid}.{compr}.{method}"
    run:
        with open(str(output), 'w', newline='\n') as fd:
            writer = csv.writer(fd)
            writer.writerows(
                exec_multiple_range_queries(ipair(wildcards.inid), wildcards.method, wildcards.compr)
            )

rule ridx_rquery:
    wildcard_constraints:
        method="(indexed)",
    input:
        ms=ipair("{inid}").compr_ms_path("{compr}"),
        idx=ipair("{inid}").ridx(block_size)
    output:
        "{inid}.{compr}.{method}"
    run:
        with open(str(output), 'w', newline='\n') as fd:
            writer = csv.writer(fd)
            writer.writerows(
                exec_multiple_range_queries(ipair(wildcards.inid), 'indexed', wildcards.compr)
            )

rule prepare_ms:
    input:
        i(ipair("{inid}").ms_path)
    output:
        ipair("{inid}").compr_ms_path("{compr}")
    params:
        exe=compress_ms
    shell:
        ("if [ '{wildcards.compr}' == 'none' ] ; "
         "then cp -v {input} {output}; "
         "else {params.exe} -ms_path {input} -compression {wildcards.compr} && "
         "mv `dirname {input}`/{output} .; "
         "fi")

rule ridx:
    input:
        ipair("{inid}").compr_ms_path("none")
    output:
        ipair("{inid}").ridx(block_size)
    params:
        exe=range_index,
        bsize=block_size
    shell:
        ("{params.exe} -ms_path {input} -block_size {params.bsize}")


